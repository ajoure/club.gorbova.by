ЖЁСТКИЕ ПРАВИЛА ИСПОЛНЕНИЯ ДЛЯ LOVABLE.DEV (ОБЯЗАТЕЛЬНО)
1) Ничего не ломать и не трогать лишнее. Только по пунктам ниже.
2) Add-only где возможно; если нужно удалить — удалять только явно указанное.
3) Dry-run → Execute: сначала показать, что будет изменено (какие файлы/строки/компоненты), потом вносить правки.
4) Никаких хардкод-UUID. Идентификация только по slug/product_code/логическим ключам.
5) STOP-guards: при отсутствии данных (module not found, user null) — безопасный fallback без краша.
6) Без PII в логах: не логировать email/телефоны/ответы пользователя. Допустимо: module.slug, lesson.id, user_id (обрезать).
7) Финальный отчёт DoD: скрины UI + список изменённых файлов + diff-summary + проверочные кейсы из DoD.

СПРИНТ: /products — логика “Все продукты” vs “Моя библиотека” + admin always-sees-all

ЦЕЛЬ:
1) “Все продукты” = витрина (только ProductCard со ссылками на лендинги), без ModuleCard.
2) “Моя библиотека” = библиотека обучения (ModuleCard), но только те модули, к которым есть доступ (has_access=true).
3) Админ видит ВСЁ всегда: все модули в библиотеке и все продукты в витрине (без ограничений), независимо от покупок.
4) Никаких дублей “Бухгалтерия как бизнес”. Источник данных обучения — ТОЛЬКО реальный модуль из БД (через админку).

------------------------------------------------------------
PATCH-1 (BLOCKER): Admin bypass — единый источник правды в useTrainingModules
------------------------------------------------------------
ПРОБЛЕМА:
Сейчас “админ видит всё” реализуется кусочно на страницах. Нужно сделать это на уровне hook-а, который отдаёт modules[].

ИЗМЕНЕНИЯ:
Файл: src/hooks/useTrainingModules.tsx (или аналогичный хук, где формируется modules и поле has_access)

1) Импортировать usePermissions (или текущий механизм RBAC):
- const { isAdmin } = usePermissions();  (или isAdminUser)

2) В самом конце, перед setModules(...), принудительно выставлять has_access=true для админа:
Псевдокод:
const isAdminUser = isAdmin?.() === true;

const normalized = (modulesData || []).map(m => ({
  ...m,
  has_access: isAdminUser ? true : Boolean(m.has_access),
}));

setModules(normalized);

STOP-GUARD:
Если permissions ещё грузятся — не ломать, считать isAdminUser=false до готовности.

DoD:
- Под админом: любой модуль в системе имеет has_access=true и отображается в “Моя библиотека”.
- Под юзером: has_access остаётся прежним.

------------------------------------------------------------
PATCH-2 (BLOCKER): Learning.tsx — “Все продукты” = только витрина, без ModuleCard
------------------------------------------------------------
ПРОБЛЕМА:
Сейчас во вкладке “Все продукты” показываются и статичные карточки, и модули (ModuleCard), из-за чего “Бухгалтерия как бизнес” может попадать туда как модуль обучения.

ИЗМЕНЕНИЯ:
Файл: src/pages/Learning.tsx

1) Во вкладке “Все продукты” УДАЛИТЬ рендер списка модулей:
- удалить блок:
{allProductsModules.map((module) => (
  <ModuleCard key={module.id} module={module} />
))}

2) Вкладка “Все продукты” должна показывать только ProductCard (Клуб/Курс/Консультация/Бухгалтерия как бизнес) со ссылками на лендинги.

DoD:
- В “Все продукты” нет ни одной карточки ModuleCard.
- Только статичные карточки с кнопкой “На сайт”.

------------------------------------------------------------
PATCH-3 (BLOCKER): Learning.tsx — “Моя библиотека” = модули по has_access (а не menu_section_key)
------------------------------------------------------------
ПРОБЛЕМА:
Фильтрация libraryModules по menu_section_key ломает доступ: модуль “Бухгалтерия как бизнес” может иметь menu_section_key="products" и не попадать в библиотеку.

ИЗМЕНЕНИЯ:
Файл: src/pages/Learning.tsx

1) Заменить вычисление libraryModules:
БЫЛО (примерно): menu_section_key === "products-library"
СТАЛО:
const libraryModules = modules.filter(m =>
  m.is_active &&
  m.has_access === true &&
  (m.menu_section_key?.startsWith("products") ?? true) // мягко: не блокировать из-за пустого key
);

Примечание: startsWith("products") оставляем как мягкий guard, но решающее — has_access.

2) Empty-state “Библиотека пуста” показывать только когда загрузка завершена.
- Если есть loading из useTrainingModules() — показать skeleton/loader, не “пусто”.

DoD:
- Любой модуль с has_access=true виден в “Моя библиотека”, даже если menu_section_key="products".
- “Библиотека пуста” не флешит во время загрузки.

------------------------------------------------------------
PATCH-4 (BLOCKER): Витрина — добавить ProductCard “Бухгалтерия как бизнес” со ссылкой на лендинг
------------------------------------------------------------
ПРОБЛЕМА:
После удаления ModuleCard из “Все продукты” нужен отдельный ProductCard, чтобы продукт был в витрине.

ИЗМЕНЕНИЯ:
Файл: src/pages/Learning.tsx

1) Добавить в массив products карточку “Бухгалтерия как бизнес” (ВИТРИНА):
- purchaseLink: https://business-training.gorbova.by
- badge: "Тренинг"
- duration: "Квест"
- image: buhBusinessImage (добавить импорт/asset)

ВАЖНО:
Это только витрина. Обучение берётся из реального модуля в БД через “Моя библиотека”.

DoD:
- В “Все продукты” есть карточка “Бухгалтерия как бизнес” → кнопка “На сайт”.

------------------------------------------------------------
PATCH-5 (BLOCKER): “Куплено” для витрины — без UUID, без отдельного запроса на BUH_PRODUCT_ID
------------------------------------------------------------
ПРОБЛЕМА:
План предлагает отдельный запрос subscriptions_v2 с product_id (нужен UUID) — запрещено. И это дублирует источники доступа.

РЕШЕНИЕ (упрощаем и стабилизируем):
- Бейдж “Куплено” на витрине ставим по факту доступа к связанному модулю (slug).
- Для “Бухгалтерии как бизнес”: если в modules есть slug 'buhgalteriya-kak-biznes' и has_access=true → “Куплено”.
- Для остальных продуктов — как было (если есть свой механизм clubAccess и т.п.).

ИЗМЕНЕНИЯ:
Файл: src/pages/Learning.tsx

1) При построении enrichedProducts:
- найти matchingModule по product.courseSlug
- если найден и matchingModule.has_access → isPurchased=true, badge="Куплено"
- НЕ делать отдельный useQuery с subscriptions_v2 product_id.

STOP-GUARD:
Если module не найден — не ставить “Куплено”, оставить дефолт.

DoD:
- Витрина показывает “Куплено” без отдельных запросов и без UUID.
- Admin (через PATCH-1) увидит “Куплено” для всех продуктов, у которых есть связанный модуль.

------------------------------------------------------------
PATCH-6 (NON-BLOCKER, но желательно): Дедуп модулей в UI по slug
------------------------------------------------------------
ПРОБЛЕМА:
Если где-то вернутся старые статические/особые блоки, могут появиться дубли.

ИЗМЕНЕНИЯ:
Файл: src/pages/Learning.tsx

1) Перед рендером libraryModules сделать дедуп по slug:
const seen = new Set<string>();
const uniqueLibraryModules = libraryModules.filter(m => {
  const key = m.slug || m.id;
  if (seen.has(key)) return false;
  seen.add(key);
  return true;
});

Использовать uniqueLibraryModules для рендера.

DoD:
- В “Моя библиотека” никогда не показывается 2 одинаковых модуля.

------------------------------------------------------------
ГРАНИЦЫ / ВАЖНО
------------------------------------------------------------
- Админ видит всё: реализуем через PATCH-1 (useTrainingModules).
- “Все продукты” — только витрина, модулей там НЕТ.
- “Моя библиотека” — только обучение (ModuleCard) по has_access.
- Никаких UUID (PRODUCT_ID_BUH_BUSINESS) — удаляем из плана.

------------------------------------------------------------
ФАЙЛЫ ДЛЯ ИЗМЕНЕНИЯ
------------------------------------------------------------
1) src/hooks/useTrainingModules.tsx
2) src/pages/Learning.tsx

------------------------------------------------------------
DoD (ПРОВЕРКИ)
------------------------------------------------------------
A) Все продукты
1) Есть карточки: Клуб, Курс, Консультация, Бухгалтерия как бизнес.
2) У всех кнопка “На сайт” ведёт на лендинг.
3) ModuleCard не рендерится вообще.

B) Моя библиотека
1) Рендерятся только модули с has_access=true (для юзера).
2) Для админа рендерятся все активные модули (has_access принудительно true).
3) Нет дублей по slug.
4) Нет “flash: библиотека пуста” при загрузке (loader → список).

C) Регрессия доступа
1) Обычный пользователь без доступа не видит модуль в “Моя библиотека”.
2) Админ видит модуль всегда.

ФИНАЛЬНЫЙ ОТЧЁТ:
- Скрин “Все продукты” (только ProductCard)
- Скрин “Моя библиотека” (ModuleCard по has_access)
- Скрин под админом (видно всё)
- Diff-summary + список файлов