
Цель: провести расследование, почему с 5 февраля (после публикации) часть существующих backend‑функций стала «NOT_DEPLOYED/404», почему «чинится и снова ломается», и сделать так, чтобы это больше не повторялось (без авто‑redeploy из админки, как вы согласовали).

---

## 0) Что уже удалось установить по фактам (сейчас)

### 0.1 Симптомы в UI = “Load failed”, но первопричина часто 404/NOT_FOUND
В текущих network‑логах браузера видно:
- `GET /functions/v1/public-product?...` → **Error: Load failed**

Это типично для ситуации, когда endpoint отвечает 404/NOT_FOUND **без корректных CORS‑заголовков** → браузер не показывает 404, а показывает “Load failed”.

Параллельно в `function_edge_logs` (логи вызовов функций) видно явные:
- `OPTIONS | 404 | .../functions/v1/public-product?...`
- `POST | 404 | .../functions/v1/payment-method-verify-recurring`
- `POST | 404 | .../functions/v1/telegram-check-expired`
- `POST | 404 | .../functions/v1/telegram-media-worker-cron`
и т.д.

То есть часть функций реально **не развернута** в том backend‑окружении, куда обращается приложение.

### 0.2 В репозитории код функций есть
В `supabase/functions/` папки присутствуют (включая `public-product/`, `payment-method-verify-recurring/`, `integration-healthcheck/`, и т.д.). Значит проблема не в “функции удалили из кода”, а на уровне **деплоя/среды**.

### 0.3 Нехватка исторических логов именно на 5 февраля
Доступная сейчас ретенция `function_edge_logs` очень короткая (видим события в основном за последние часы), поэтому “точное время первого 404 5 февраля” из этих логов восстановить нельзя. Зато можно построить достоверную причинно‑следственную схему и поставить «черный ящик», чтобы следующий раз был 100% трассируем.

---

## 1) Главная гипотеза причины (почему “после publish” и “чинится и снова ломается”)

У вас есть GitHub Actions деплой функций: `.github/workflows/deploy-functions.yml`.

Критический момент:
- Workflow запускается **только если изменялись файлы в `supabase/functions/**`** (см. `paths:`).
- При этом вы сказали: проблемы начались после **публикации** (“Публиковали изменения”), и ломается **и в preview, и на опубликованном сайте**.

На практике это часто выглядит так:
1) Публикация/релиз пересобирает/переключает окружение (или меняет версию backend‑слоя), после чего функции оказываются в состоянии “не задеплоены / не доступны”.
2) Но GitHub workflow **не запускается** (потому что publish мог не менять `supabase/functions/**`), и функции не “переустанавливаются”.
3) Вы “чините” точечно (деплоите 1‑2 функции), но следующая публикация/сборка снова возвращает систему в состояние без полного набора функций → ощущение “нерешаемо, оно снова возникает”.

Второй возможный фактор (усиливает эффект):
- Разные окружения (preview vs published) могут иметь разные состояния развернутых функций. Без явной диагностики “какое окружение к какому backend подключено” это воспринимается как “отвязалось”.

---

## 2) План расследования (доказательно, с привязкой ко времени/событию)

### 2.1 Собрать “карту реальных падений” по критичным областям
Сфокусируемся на P0 для вас: **платежи, интеграции, админка**.
Действия (read-only/безопасно):
- Составить allowlist функций, которые реально критичны (пример: `public-product`, `payment-method-verify-recurring`, `payment-methods-tokenize`, `bepaid-create-token`, `bepaid-list-subscriptions`, `admin-payments-diagnostics`, `integration-healthcheck`, `integration-sync`, `amocrm-sync`, `getcourse-sync`, и т.п.).
- Для каждой функции сделать проверку доступности (OPTIONS + POST/GET ping) в обоих сценариях:
  - вызов “как из браузера” (CORS preflight)
  - вызов “как сервер” (простой POST ping)

Результат: таблица “функция → статус (404 / CORS / OK)”.

### 2.2 Ввести “идентификатор среды” (чтобы доказать, где именно ломается)
Нужен стабильный способ увидеть в UI:
- какой backend endpoint/окружение сейчас используется
- какая “версия/деплой” backend‑функций

Для этого добавим легковесную диагностическую backend‑функцию (например `backend-env-info`) и маленький блок в админке:
- показывает: `env_kind` (preview/published), `projectRef` (внутренне), `timestamp`, `edge_runtime` сведения (что доступно), и “canary checks” 3–5 ключевых функций.
- это не рефакторинг, а точечный диагностический слой.

Так вы сможете сами увидеть: “после publish мы начали ходить в окружение X, где функций 0/не те”.

### 2.3 Зафиксировать момент “после каких событий”
Так как логов вызовов функций на 5 февраля уже недостаточно, мы поставим аудит на будущее:
- при каждом успешном деплое функций CI будет писать запись в БД (например `deployment_events`) или в `audit_logs` с типом `system.edge_functions.deployed` и метаданными:
  - время
  - сколько функций попытались развернуть
  - сколько smoke‑checks прошло
  - идентификатор workflow run (если передадим)
Это даст 100% ответ “после какого деплоя началось”.

---

## 3) План устранения первопричины (чтобы не повторялось)

### 3.1 Исправить CI так, чтобы publish не мог оставить backend без функций
Точечные правки в `.github/workflows/deploy-functions.yml`:

1) Убрать ограничение `paths: supabase/functions/**`
- чтобы деплой функций запускался на **любой push в main** (включая publish‑коммиты), а не только когда правили функции.
- это ключевой стабилизатор “после publish”.

2) Сделать список деплоя детерминированным и полным
- вместо `git diff HEAD~1 HEAD` (который на merge/нескольких коммитах может давать сюрпризы) — просто деплоить все директории в `supabase/functions/*/` где есть `index.ts`.

3) Усилить smoke‑checks (не только TIER‑1)
- добавить второй уровень smoke‑checks: “must_exist” функции (платежи/интеграции/админка) — короткая проверка OPTIONS/POST.
- Fail-fast сохраняем.

Это не auto‑redeploy из админки, а нормальная инженерная гарантия: “после publish функции всегда оказываются на месте”.

### 3.2 Добавить “canary” в систему (раннее обнаружение)
- В `nightly-system-health` или отдельном легком cron‑чеке: проверять 5–10 самых важных функций.
- Если 404/NOT_FOUND — сразу уведомление вам, и в отчете явно: “не развернуты функции” (а не “нет прав”).

---

## 4) План “привести систему в рабочее состояние сейчас” (безопасно, с предохранителями)

Так как сейчас реально видны 404 на важных функциях, потребуется контролируемый redeploy.

Ограничения (по вашим правилам “STOP‑предохранители”):
- Деплоим батчами по 5–10 функций
- После каждого батча — проверка доступности (и запись результата)
- Начинаем строго с платежей/интеграций/админки (то, что у вас критично)

Батчи (пример, финальный список уточним по результатам пункта 2.1):
- Batch A (Payments): `payment-method-verify-recurring`, `payment-methods-tokenize`, `bepaid-create-token`, `bepaid-list-subscriptions`, `bepaid-get-subscription-details`, `admin-payments-diagnostics`
- Batch B (Integrations): `integration-healthcheck`, `integration-sync`, `amocrm-sync`, `getcourse-sync`, `getcourse-webhook`
- Batch C (Admin critical): `users-admin-actions`, `roles-admin`, `subscription-actions`, `subscription-admin-actions`
- Batch D (Public entrypoints): `public-product` (и всё, что реально дергается лендингом/публичными страницами)

Важно: это не “массовая операция без контроля” — это управляемая процедура с проверкой после каждого шага.

---

## 5) DoD (что будет считаться завершением расследования и фикса)

1) Доказательство причины:
- В админке отображается “Backend Env Info” и видно отличие окружений/версий до/после publish (или факт, что после publish CI не запускался из‑за `paths` и поэтому функции не поднимались).
- В БД/аудите есть запись “деплой функций прошел” с временем.

2) Доказательство исправления “здесь и сейчас”:
- `public-product` перестает давать “Load failed” в preview и на опубликованном сайте.
- Ключевые платежные и интеграционные функции перестают отвечать 404 (проверка OPTIONS/POST).

3) Доказательство “не повторится”:
- CI запускает деплой функций на каждый push в main (включая publish‑коммиты).
- Smoke checks падают, если функция недоступна → нельзя “тихо” уехать в 404.

4) Отчет с пруфами (как вы требуете):
- Скриншоты UI (админка) после фикса: запуск проверок/статус без ошибок
- SQL-пруфы: выборки из таблиц деплой‑эвентов/аудит‑логов (SELECT)
- Diff‑summary: какие файлы изменены (workflow + диагностическая функция + минимальные UI изменения)

---

## Что мне нужно будет сделать в режиме Execute (после этого плана)
1) Внести правки в GitHub workflow (CI).
2) Добавить диагностическую backend‑функцию + маленький блок в админке.
3) Провести контролируемый redeploy ключевых функций батчами и подтвердить пруфами (скрины + SELECT).
